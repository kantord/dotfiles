#!/usr/bin/env bash
# ha-i3: minimal Home Assistant CLI for i3 keybinds
# - Caches token in RAM file
# - Fetches from pass on first use: homeassistant/i3wm_cli_token
# - Requires: curl; jq (for clean output on `list`)
set -euo pipefail

# ====== CONFIG ======
HASS_SERVER="${HASS_SERVER:-http://homeassistant.local:8123}"
PASS_PATH="${PASS_PATH:-homeassistant/i3wm_cli_token}"
RAM_DIR="/run/user/$(id -u)"
TOKEN_FILE="${TOKEN_FILE:-$RAM_DIR/ha_token}"
CODE_FILE="$RAM_DIR/ha_http_code"   # last HTTP status code (non-sensitive)
# ====================

die() { printf 'Error: %s\n' "$*" >&2; exit 1; }

need() { command -v "$1" >/dev/null 2>&1 || die "Missing dependency: $1"; }
need curl

ensure_ramdir() { [ -d "$RAM_DIR" ] || die "No $RAM_DIR (no user tmpfs?)"; }

load_or_fetch_token() {
  ensure_ramdir
  # If HASS_TOKEN is provided via env, skip pass entirely
  if [ -n "${HASS_TOKEN:-}" ]; then
    return
  fi
  if [ ! -f "$TOKEN_FILE" ]; then
    need pass
    umask 177
    # read first line only (pass entries can have extra notes)
    # write token without trailing newline characters
    pass show "$PASS_PATH" | head -n1 | tr -d '\r\n' > "$TOKEN_FILE"
    chmod 600 "$TOKEN_FILE"
  fi
}

token() {
  if [ -n "${HASS_TOKEN:-}" ]; then
    printf '%s' "$HASS_TOKEN" | tr -d '\r\n \t'
  else
    tr -d '\r\n \t' < "$TOKEN_FILE"
  fi
}

# Build a one-off curl config file in RAM to avoid leaking the token in argv.
# Args: METHOD URL DATA_JSON(optional)
curl_call() {
  local method="$1" url="$2" data="${3:-}" conf
  conf=$(mktemp -p "$RAM_DIR" ha_curl.XXXX)
  umask 177
  {
    printf 'header = "Authorization: Bearer %s"\n' "$(token)"
    printf 'header = "Content-Type: application/json"\n'
    printf 'request = %s\n' "$method"
    printf 'url = "%s"\n' "$url"
    if [ -n "$data" ]; then
      # Escape newlines and quotes safely
      local data_escaped
      data_escaped=$(printf '%s' "$data" | sed 's/"/\\"/g')
      printf 'data = "%s"\n' "$data_escaped"
    fi
  } > "$conf"
  chmod 600 "$conf"
  curl -sS -K "$conf"
  rm -f "$conf"
}

# Like curl_call, but also captures HTTP status into HAI3_HTTP_CODE and does not exit on HTTP errors.
curl_call_code() {
  local method="$1" url="$2" data="${3:-}" tmp_body http_code status conf
  tmp_body="$(mktemp -p "$RAM_DIR" ha_body.XXXX)"
  conf=$(mktemp -p "$RAM_DIR" ha_curl.XXXX)
  umask 177
  {
    printf 'header = "Authorization: Bearer %s"\n' "$(token)"
    printf 'header = "Content-Type: application/json"\n'
    printf 'request = %s\n' "$method"
    printf 'url = "%s"\n' "$url"
    if [ -n "$data" ]; then
      local data_escaped
      data_escaped=$(printf '%s' "$data" | sed 's/"/\\"/g')
      printf 'data = "%s"\n' "$data_escaped"
    fi
  } > "$conf"
  chmod 600 "$conf"
  set +e
  http_code=$(curl -sS --fail-with-body -K "$conf" -w "%{http_code}" -o "$tmp_body")
  status=$?
  set -e
  umask 177; printf '%s' "$http_code" > "$CODE_FILE"; chmod 600 "$CODE_FILE"
  cat "$tmp_body"
  rm -f "$tmp_body"
  rm -f "$conf"
  return 0
}

list_lights() {
  # GET /api/states and filter light.*; pretty-print with jq if available
  local url="${HASS_SERVER%/}/api/states"
  local out http_code
  out="$(curl_call_code GET "$url")"
  http_code=$(cat "$CODE_FILE" 2>/dev/null || printf '')
  if [ "$http_code" != "200" ]; then
    printf 'Error: HTTP %s from Home Assistant when listing states.\n' "${http_code:-unknown}" >&2
    printf 'Hint: check HASS_SERVER=%s and token. You can export HASS_TOKEN to test.\n' "$HASS_SERVER" >&2
    printf 'Raw response (truncated):\n' >&2
    printf '%s' "$out" | head -c 500 >&2; printf '\n' >&2
    exit 1
  fi
  if command -v jq >/dev/null 2>&1; then
    # Validate JSON before filtering to avoid jq parse errors on HTML/text errors
    if ! printf '%s' "$out" | jq -e . >/dev/null 2>&1; then
      printf 'Error: unexpected response from Home Assistant.\n' >&2
      printf 'Hint: verify HASS_SERVER=%s and your token (pass show %s).\n' "$HASS_SERVER" "$PASS_PATH" >&2
      printf 'Raw response (truncated):\n' >&2
      printf '%s' "$out" | head -c 500 >&2; printf '\n' >&2
      exit 1
    fi
    printf '%s' "$out" | jq -r '
      .[] | select(.entity_id | startswith("light.")) |
      "\(.entity_id)\t\(.attributes.friendly_name // "-")"
    ' | sort
  else
    # basic fallback without jq
    printf '%s\n' "Tip: install jq for nicer output."
    printf '%s' "$out" | grep -o '"entity_id":"light\.[^"]*"\|"friendly_name":"[^"]*"' \
      | sed 's/"entity_id"://;s/"friendly_name"://' | paste - - | sort
  fi
}

set_brightness() {
  local entity="$1" level="$2"
  # clamp level 0..255
  if ! [[ "$level" =~ ^[0-9]+$ ]]; then die "Brightness must be 0..255"; fi
  if [ "$level" -lt 0 ] || [ "$level" -gt 255 ]; then die "Brightness must be 0..255"; fi
  local url="${HASS_SERVER%/}/api/services/light/turn_on"
  local payload
  payload=$(printf '{"entity_id":"%s","brightness":%d}' "$entity" "$level")
  curl_call POST "$url" "$payload" >/dev/null
}

# Convert percentage [0-100] to brightness [0-255] with rounding
pct_to_brightness() {
  local pct="$1" b
  if ! [[ "$pct" =~ ^[0-9]+$ ]]; then die "Percent must be 0..100"; fi
  if [ "$pct" -lt 0 ] || [ "$pct" -gt 100 ]; then die "Percent must be 0..100"; fi
  # Round: (pct*255 + 50)/100
  b=$(( (pct * 255 + 50) / 100 ))
  printf '%d' "$b"
}

# Convert brightness [0-255] to percentage [0-100] with rounding
brightness_to_pct() {
  local b="$1" p
  if ! [[ "$b" =~ ^[0-9]+$ ]]; then die "Brightness must be 0..255"; fi
  if [ "$b" -lt 0 ] || [ "$b" -gt 255 ]; then die "Brightness must be 0..255"; fi
  # Round: (b*100 + 127)/255
  p=$(( (b * 100 + 127) / 255 ))
  printf '%d' "$p"
}

set_brightness_pct() {
  local entity="$1" pct="$2"
  if ! [[ "$pct" =~ ^[0-9]+$ ]]; then die "Percent must be 0..100"; fi
  if [ "$pct" -lt 0 ] || [ "$pct" -gt 100 ]; then die "Percent must be 0..100"; fi
  if [ "$pct" -eq 0 ]; then
    # Turn off at 0%
    local url_off="${HASS_SERVER%/}/api/services/light/turn_off"
    local payload_off
    payload_off=$(printf '{"entity_id":"%s"}' "$entity")
    curl_call POST "$url_off" "$payload_off" >/dev/null
    return
  fi
  local b
  b=$(pct_to_brightness "$pct")
  set_brightness "$entity" "$b"
}

get_current_brightness() {
  local entity="$1" url out
  url="${HASS_SERVER%/}/api/states/${entity}"
  out="$(curl_call_code GET "$url")"
  local http_code
  http_code=$(cat "$CODE_FILE" 2>/dev/null || printf '')
  if [ "$http_code" != "200" ]; then
    die "Failed to read state (HTTP ${http_code:-unknown})"
  fi
  if command -v jq >/dev/null 2>&1; then
    printf '%s' "$out" | jq -r '.attributes.brightness // 0'
  else
    # Fallback: naive extraction
    printf '%s' "$out" | grep -o '"brightness":[0-9]\+' | head -n1 | cut -d: -f2 | tr -d '\n' | sed 's/^$/0/'
  fi
}

adjust_brightness_pct() {
  local entity="$1" delta="$2"
  # Accept +N, -N, or N (treated as +N)
  if ! [[ "$delta" =~ ^[+-]?[0-9]+$ ]]; then die "Delta must be an integer percent, e.g. +10 or -10"; fi
  # Read current brightness (0..255) then to percent
  local cur_b cur_pct new_pct
  cur_b=$(get_current_brightness "$entity")
  if ! [[ "$cur_b" =~ ^[0-9]+$ ]]; then cur_b=0; fi
  cur_pct=$(brightness_to_pct "$cur_b")
  # Normalize delta: strip leading + if present
  if [[ "$delta" =~ ^\+ ]]; then delta="${delta:1}"; fi
  new_pct=$(( cur_pct + delta ))
  if [ "$new_pct" -lt 0 ]; then new_pct=0; fi
  if [ "$new_pct" -gt 100 ]; then new_pct=100; fi
  set_brightness_pct "$entity" "$new_pct"
}

usage() {
  cat <<EOF
ha-i3 — minimal HA helper

USAGE:
  ha-i3 list
      List all light entities (entity_id and friendly name).

  ha-i3 set <entity_id> <0..100>
      Set brightness as percent. 0% turns the light off. (Alias: set-pct)

  ha-i3 adjust <entity_id> <+N|-N>
      Adjust brightness by N percent points. Requires jq for accuracy.

  ha-i3 color <entity_id> <R> <G> <B>
      Set RGB color (0..255 per component).

  ha-i3 hs <entity_id> <H 0..360> <S 0..100>
      Set color via HS (hue/saturation).

  ha-i3 state <entity_id>
      Print raw JSON state for the entity.

  ha-i3 ct <entity_id> <kelvin>
      Set white spectrum using color temperature in Kelvin.

  ha-i3 refresh-token
      Drop cached token and refetch from pass.

  ha-i3 probe
      Check connectivity and authentication against Home Assistant.

ENV:
  HASS_SERVER   (default: $HASS_SERVER)
  PASS_PATH     (default: $PASS_PATH)
  TOKEN_FILE    (default: $TOKEN_FILE)

Examples:
  ha-i3 list
  ha-i3 set light.living_room 160
  ha-i3 refresh-token
  ha-i3 probe
EOF
}

probe() {
  local url_cfg="${HASS_SERVER%/}/api/config";
  local out http_code
  out="$(curl_call_code GET "$url_cfg")"
  http_code=$(cat "$CODE_FILE" 2>/dev/null || printf '')
  if [ "$http_code" = "200" ] && command -v jq >/dev/null 2>&1 && printf '%s' "$out" | jq -e . >/dev/null 2>&1; then
    printf 'OK: Authenticated at %s (api/config reachable).\n' "$HASS_SERVER"
    return 0
  fi
  printf 'Probe failed (HTTP %s). Raw response (truncated):\n' "${http_code:-unknown}" >&2
  printf '%s' "$out" | head -c 500 >&2; printf '\n' >&2
  exit 1
}

token_info() {
  local t
  t="$(token)"
  if [ -z "$t" ]; then
    printf 'No token loaded.\n'
    return 1
  fi
  local len=${#t}
  local head=${t:0:6}
  local tail=${t: -4}
  printf 'Token length: %d, fingerprint: %s…%s\n' "$len" "$head" "$tail"
}

main() {
  [ $# -ge 1 ] || { usage; exit 1; }
  load_or_fetch_token

  case "$1" in
    list)
      list_lights
      ;;
    set)
      [ $# -eq 3 ] || die "Usage: ha-i3 set <entity_id> <0..100>"
      set_brightness_pct "$2" "$3"
      ;;
    set-pct)
      [ $# -eq 3 ] || die "Usage: ha-i3 set-pct <entity_id> <0..100>"
      set_brightness_pct "$2" "$3"
      ;;
    adjust)
      [ $# -eq 3 ] || die "Usage: ha-i3 adjust <entity_id> <+N|-N>"
      adjust_brightness_pct "$2" "$3"
      ;;
    color)
      [ $# -eq 5 ] || die "Usage: ha-i3 color <entity_id> <R> <G> <B>"
      if ! [[ "$3" =~ ^[0-9]+$ && "$4" =~ ^[0-9]+$ && "$5" =~ ^[0-9]+$ ]]; then
        die "RGB components must be integers 0..255"
      fi
      if [ "$3" -gt 255 ] || [ "$4" -gt 255 ] || [ "$5" -gt 255 ]; then
        die "RGB components must be 0..255"
      fi
      url="${HASS_SERVER%/}/api/services/light/turn_on"
      payload=$(printf '{"entity_id":"%s","rgb_color":[%d,%d,%d]}' "$2" "$3" "$4" "$5")
      curl_call POST "$url" "$payload" >/dev/null
      ;;
    hs)
      [ $# -eq 4 ] || die "Usage: ha-i3 hs <entity_id> <H 0..360> <S 0..100>"
      H="$3"; S="$4"
      if ! [[ "$H" =~ ^[0-9]+$ && "$S" =~ ^[0-9]+$ ]]; then
        die "H and S must be integers (H:0..360, S:0..100)"
      fi
      if [ "$H" -gt 360 ] || [ "$S" -gt 100 ]; then
        die "H must be 0..360 and S 0..100"
      fi
      url="${HASS_SERVER%/}/api/services/light/turn_on"
      payload=$(printf '{"entity_id":"%s","hs_color":[%d,%d]}' "$2" "$H" "$S")
      curl_call POST "$url" "$payload" >/dev/null
      ;;
    state)
      [ $# -eq 2 ] || die "Usage: ha-i3 state <entity_id>"
      url="${HASS_SERVER%/}/api/states/$2"
      out="$(curl_call_code GET "$url")"
      http_code=$(cat "$CODE_FILE" 2>/dev/null || printf '')
      if [ "$http_code" != "200" ]; then
        printf '%s' "$out" >&2
        exit 1
      fi
      printf '%s' "$out"
      ;;
    ct)
      [ $# -eq 3 ] || die "Usage: ha-i3 ct <entity_id> <kelvin>"
      K="$3"
      if ! [[ "$K" =~ ^[0-9]+$ ]] || [ "$K" -lt 1000 ] || [ "$K" -gt 10000 ]; then
        die "Kelvin must be an integer 1000..10000"
      fi
      # Also send color_temp (mireds) for broader compatibility
      # mireds = 1e6 / K
      MIR=$(( 1000000 / K ))
      url="${HASS_SERVER%/}/api/services/light/turn_on"
      # Strategy: try color_temp (mireds) first, then color_temp_kelvin, then turn_on+retry.
      # If jq is present, verify by reading state after each try.
      try_apply() {
        local mode="$1"; shift
        local data="$1"; shift
        curl_call POST "$url" "$data" >/dev/null || true
        if command -v jq >/dev/null 2>&1; then
          sleep 0.15
          local st out http_code
          out="$(curl_call_code GET "${HASS_SERVER%/}/api/states/$2")"
          http_code=$(cat "$CODE_FILE" 2>/dev/null || printf '')
          if [ "$http_code" = "200" ]; then
            if [ "$mode" = "mired" ]; then
              printf '%s' "$out" | jq -e --argjson want "$MIR" '(.attributes.color_temp // -1) as $ct | ($ct >= 0 and (($ct - $want) | tonumber | abs) <= 2)' >/dev/null 2>&1 && return 0
            else
              # Accept either kelvin or mireds match
              printf '%s' "$out" | jq -e --argjson wantk "$K" --argjson wantm "$MIR" '((.attributes.color_temp_kelvin // -1) as $k | $k == $wantk) or ((.attributes.color_temp // -1) as $m | ($m >= 0 and (($m - $wantm) | tonumber | abs) <= 2))' >/dev/null 2>&1 && return 0
            fi
          fi
          return 1
        else
          return 0
        fi
      }

      # 1) mireds
      payload=$(printf '{"entity_id":"%s","color_temp":%d}' "$2" "$MIR")
      if try_apply mired "$payload" "$2"; then exit 0; fi
      # 2) kelvin
      payload=$(printf '{"entity_id":"%s","color_temp_kelvin":%d}' "$2" "$K")
      if try_apply kelvin "$payload" "$2"; then exit 0; fi
      # 3) turn on, then mireds then kelvin
      curl_call POST "$url" "$(printf '{"entity_id":"%s"}' "$2")" >/dev/null || true
      payload=$(printf '{"entity_id":"%s","color_temp":%d}' "$2" "$MIR")
      if try_apply mired "$payload" "$2"; then exit 0; fi
      payload=$(printf '{"entity_id":"%s","color_temp_kelvin":%d}' "$2" "$K")
      if try_apply kelvin "$payload" "$2"; then exit 0; fi
      printf 'Warning: failed to set color temperature for %s to %sK\n' "$2" "$K" >&2
      exit 1
      ;;
    refresh-token)
      rm -f "$TOKEN_FILE"
      load_or_fetch_token
      printf 'Token refreshed from pass path: %s\n' "$PASS_PATH"
      ;;
    probe)
      probe
      ;;
    token-info)
      token_info
      ;;
    -h|--help)
      usage
      ;;
    *)
      die "Unknown command: $1"
      ;;
  esac
}

main "$@"
